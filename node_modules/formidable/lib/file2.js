if (global.GENTLY) require = GENTLY.hijack(require);

var util = require('util'),
    fs = require('fs'),
    EventEmitter = require('events').EventEmitter,
    crypto = require('crypto');

/**
 * used for the case: 
 * 1. use hash as part of fileName to avoid file overwrite
 * 2. do not save file if necessary
 *
 * Notice:
 * 1. as file is not write during upload, maxFileSize should be set to avoid outOfMemory 
 */
function File(properties) {
  EventEmitter.call(this);

  this.size = 0;
  this.path = null;
  this.name = null;
  this.type = null;
  this.hash = null;
  this.lastModifiedDate = null;
  this.data = '';

  // for compatable
  this._writeStream = {
    destroy() {
    }
  }

  for (var key in properties) {
    this[key] = properties[key];
  }

  if(typeof this.hash === 'string') {
    this.hash = crypto.createHash(properties.hash);
  } else {
    this.hash = null;
  }
}
module.exports = File;
util.inherits(File, EventEmitter);

File.prototype.open = function() {
  this._buffer = [];
};

File.prototype.toJSON = function() {
  var json = {
    size: this.size,
    path: this.path,
    name: this.name,
    type: this.type,
    mtime: this.lastModifiedDate,
    length: this.length,
    filename: this.filename,
    mime: this.mime,
    data: this.data
  };
  if (this.hash && this.hash != "") {
    json.hash = this.hash;
  }
  return json;
};

File.prototype.write = function(buffer, cb) {
  var self = this;
  if (self.hash) {
    self.hash.update(buffer);
  }

  self._buffer.push(buffer);
  self.lastModifiedDate = new Date();
  self.size += buffer.length;
  self.emit('progress', self.size);
  cb();
};

File.prototype.end = function(cb) {
  var self = this;
  if (self.hash) {
    self.hash = self.hash.digest('hex');
  }
  self.data = Buffer.concat(self._buffer);
  self._buffer = [];
  self.emit('end');
  cb();
};
