const pathToRegexp = require('path-to-regexp');

const PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
  // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
].join('|'), 'g')

// SUMMARY
// 1. regexp parse

// /(?:\:(\w+)(?:\(((?:\\.|[^\\()])+)\))?|\(((?:\\.|[^\\()])+)\))([+*?])?/

// formatted regexp
// (\\.)
// |
// (?:
//   \:(\w+)
//   (?:
//     \(
//       (
//         (?:\\.|[^\\()])+
//       )
//     \)
//   )?
//   |
//   \(
//     (
//       (?:\\.|[^\\()])+
//     )
//   \)
// )
// ([+*?])?

// (\\.)                              1, escaped
// |
// (?:
//   \:(\w+)                          2, name
//   (?:
//     \(
//       (                            3, capture
//         (?:\\.|[^\\()])+
//       )
//     \)
//   )?
//   |
//   \(
//     (                              4, group
//       (?:\\.|[^\\()])+
//     )
//   \)
// )
// ([+*?])?                           5, modifier

class Parser {
  constructor() {
    this.testCase = [
      '/foo/bar',
      // '/:foo/:bar',
      // '/:foo/:bar?',
      // '\\d'
      // 测试capture
      // '/icon-:foo(\\d+)?.png',
      // 测试group
      '/icon-:foo(\\d+)(-abc)?.png',
      // 用于pathEscaped
      // '/abc/:def(\\d+).png'
      // '/with/\\capture/:abc/\\another'
      // '/with/\\capture/:abc(\\d+):def([a-d])/\\another',
      '/:with/\\capture/:abc(\\d+):def([a-d])/\\another/:last'
    ];
  }

  /**
   * 
   *
   */
  findKeys(str) {
    var index = 0;
    var path = '';
    var res = null;
    var tokens = [];
    var pathEscaped = false
    while ((res = PATH_REGEXP.exec(str)) !== null) {
      var m = res[0]
      var escaped = res[1]
      if (escaped) {
        path += escaped[1]
        pathEscaped = true
        continue
      }
      var offset = res.index
      path += str.slice(index, offset)
      index = offset + m.length

      var prev = ''
      var name = res[2]
      var capture = res[3]
      var group = res[4]
      var modifier = res[5]
      tokens.push({
        match: m,
        escaped,
        name,
        capture,
        group,
        modifier
      });
    }
    return tokens
  }

  testReg() {
    this.testCase.forEach(it => {
      console.log(this.findKeys(it));
      console.log('>>>>>>');
    });
  }

  testPathToRegExp() {
    this.testCase.forEach(it => {
      console.log(pathToRegexp(it));
      // console.log(this.findKeys(it));
      console.log('>>>>>>');
    });
  }
}

const obj = new Parser();
// obj.testReg();
obj.testPathToRegExp();

