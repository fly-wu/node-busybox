/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */


var State = null;
if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
  State = require('./browser.js');
} else {
  State = require('./node.js');
}
const stateHelper = new State();

/**
* Create a debugger with the given `namespace`.
*
* @param {String} namespace
* @return {Function}
* @api public
*/
function createDebug(namespaceOrOptions) {
  var namespace = namespaceOrOptions;
  var toFile = null;
  var log = null;
  if (namespaceOrOptions != null && typeof namespaceOrOptions == 'object') {
    namespace = namespaceOrOptions.namespace;
    toFile = namespaceOrOptions.toFile;
    log = namespaceOrOptions.log;
  }

  var existedDebug = stateHelper.instances.find(it => {
    return it.namespace === namespace;
  });
  if (existedDebug) {
    return existedDebug;
  }

  function debug(...args) {
    // Disabled?
    if (!debug.enabled) {
      return;
    }

    args[0] = stateHelper.coerce(args[0]);

    if (typeof args[0] !== 'string') {
      // Anything else let's inspect with %O
      args.unshift('%O');
    }

    // Apply any `formatters` transformations
    let index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
      // If we encounter an escaped % then don't increase the array index
      if (match === '%%') {
        return match;
      }
      index++;
      const formatter = stateHelper.formatters[format];
      if (typeof formatter === 'function') {
        const val = args[index];
        match = formatter.call(debug, val);

        // Now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // Apply env-specific formatting (colors, etc.)
    stateHelper.formatArgs(args, {
      namespace: debug.namespace,
      color: debug.color
    });

    const logFn = debug.log || stateHelper.log.bind(stateHelper);
    logFn(args, {
      namespace: debug.namespace,
      toFile: debug.toFile
    });
  }

  debug.writer = new class LogWriter extends require('stream').Writable {
    constructor(options) {
      super(options);
    }
    _write(chunk, encoding, next) {
      if (Buffer.isBuffer(chunk)) {
        chunk = chunk.toString();
      }
      const args = [chunk];
      // Apply env-specific formatting (colors, etc.)
      stateHelper.formatArgs(args, {
        namespace: debug.namespace,
        color: debug.color
      });
      const logFn = debug.log || stateHelper.log.bind(stateHelper);
      logFn(args, {
        namespace: debug.namespace,
        toFile: debug.toFile
      });
      next();
    }
    _final(next) {
      next();
    }
  }
  debug.namespace = namespace;
  debug.toFile = toFile;
  debug.log = log;
  debug.enabled = stateHelper.enabled(namespace);
  debug.color = stateHelper.selectColor(namespace);
  debug.destroy = function destroy() {
    const index = stateHelper.instances.indexOf(this);
    if (index !== -1) {
      stateHelper.instances.splice(index, 1);
      this.enabled = false;
      return true;
    }
    return false;
  };

  stateHelper.instances.push(debug);

  return debug;
}

createDebug.getState = function() {
  return stateHelper;
}
createDebug.enable = stateHelper.enable.bind(stateHelper);

module.exports = createDebug;
