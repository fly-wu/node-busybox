
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

// common prototype, can be used on both node and browser
module.exports = class Common {
  constructor() {
    this.colors = [];
    this.formatters = {};
    /**
    * The currently active debug mode names, and names to skip.
    */
    this.names = [];
    this.skips = [];
    /**
    * Active `debug` instances.
    */
    this.instances = [];
  }
  formatArgs() {
    throw new Error('formatArgs is a abstract function, should implement in childClass');
  }
  log() {
    throw new Error('log is a abstract function, should implement in childClass');
  }
  getConfig() {
    throw new Error('getConfig is a abstract function, should implement in childClass');
  }
  setConfig() {
    throw new Error('setConfig is a abstract function, should implement in childClass');
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  enable(namespaces) {
    this.setConfig('debug', namespaces);

    this.names = [];
    this.skips = [];

    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        this.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        this.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < this.instances.length; i++) {
      const instance = this.instances[i];
      instance.enabled = this.enabled(instance.namespace);
    }
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  disable() {
    /**
    * Convert regexp to namespace
    *
    * @param {RegExp} regxep
    * @return {String} namespace
    * @api private
    */
    function toNamespace(regexp) {
      return regexp.toString()
        .substring(2, regexp.toString().length - 2)
        .replace(/\.\*\?$/, '*');
    }
    const namespaces = [
      ...this.names.map(toNamespace),
      ...this.skips.map(toNamespace).map(namespace => '-' + namespace)
    ].join(',');
    this.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = this.skips.length; i < len; i++) {
      if (this.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = this.names.length; i < len; i++) {
      if (this.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  selectColor(namespace) {
    if (!this.colors || !Array.isArray(this.colors) || this.colors.length === 0) {
      throw new Error('colors is not found');
    }
    const colorsUsed = this.instances.map(it => {
      return it.color;
    })
    var selected = this.colors.find(color => {
      return colorsUsed.indexOf(color) === -1;
    });
    if (!selected) {
      selected = this.colors[0];
    }
    return selected;
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  init() {
    this.enable(this.getConfig().debug);
  }

  isString(s) {
    return typeof(s) === 'string' || s instanceof String;
  }
  isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  isDate(n) {
    return n instanceof Date;
  }

  /**
   * transfer to formated date string
   * @date timestamp of date
   * @fmt the format of result, such as yyyy-MM-dd hh:mm:ss.SSS
   */
  formatDate(date, fmt) {
    if (!date) {
      return '未知';
    }
    if (!this.isDate(date)) {
      if (this.isString(date)) {
        date = parseInt(date);
      }
      if (this.isNumber(date)) {
        date = new Date(date);
      }
    }
    var o = {
      'M+': date.getMonth() + 1, //月份
      'd+': date.getDate(), //日
      'h+': date.getHours(), //小时
      'm+': date.getMinutes(), //分
      's+': date.getSeconds(), //秒
      'q+': Math.floor((date.getMonth() + 3) / 3), //季度
      'S+': date.getMilliseconds() //毫秒
    };
    if (/(y+)/.test(fmt)) {
      fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
    }
    for (var k in o) {
      if (new RegExp('(' + k + ')').test(fmt)) {
        if (k === 'S+') {
          fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('000' + o[k]).substr(('' + o[k]).length)));
        } else {
          fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length)));
        }
      }
    }
    return fmt;
  }
}



